module Main (main) where
import System.Environment
 
type Z = Integer
main
  = do ((!arg) : (!_)) <- getArgs
       let d = fromIntegral (read arg :: Int) :: Z
           (n, m) = (5000, 10000) :: (Z, Z)
           ns = [n .. (n + d)]
           (!ms) = [m .. (m + d)]
           pairs = [(x, y) | x <- ns, y <- ms]
           tripls = map (\ (!(x, y)) -> (x, y, gcdE x y)) pairs
           (!rs)
             = map (\ (!((!_), _, (!(g, u, v)))) -> abs (g + u + v)) tripls
           max' (![x]) = x
           max' ((!x) : ((!y) : (!xs)))
             = if x < y then max' (y : xs) else max' (x : xs)
       putStr (shows (max' rs) "\n")
test (!(x, y, (d, u, v))) = d == (u * x + v * y) && d == (gcd x y)
 
gcdE :: Integral a => a -> a -> (a, a, a)
gcdE 0 y = (y, 0, 1)
gcdE x y = g (1, 0, x) (0, 1, y)
  where g ((!u1), u2, u3) (!((!v1), (!v2), v3))
          = if v3 == 0 then (u3, u1, u2) else
              case quotRem u3 v3 of
                  ((!q), r) -> g (v1, v2, v3) (u1 - q * v1, u2 - q * v2, r)