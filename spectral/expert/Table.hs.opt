module Table where
import Result
 
data Table k v = Empty
               | Fork (Table k v) (k, v) (Table k v)
newTable = Empty
find (!Empty) key = failure "not found"
find ((!(Fork left (!((!k), v)) right))) key
  | key < k = find left key
  | key == k = success v
  | key > k = find right key
enter (!Empty) key val = Fork Empty (key, val) Empty
enter (Fork left (!(k, v)) right) key val
  | key < k = Fork (enter left key val) (k, v) right
  | key == k = Fork left (k, v) right
  | key > k = Fork left (k, v) (enter right key val)
update Empty (!key) val = Fork Empty (key, val) Empty
update (Fork left (k, (!v)) right) key val
  | key < k = Fork (update left key val) (k, v) right
  | key == k = Fork left (key, val) right
  | key > k = Fork left (k, v) (update right key val)
delete Empty key = Empty
delete (Fork left (k, v) right) key
  | key < k = Fork (delete left key) (k, v) right
  | key == k = graft left right
  | key > k = Fork left (k, v) (delete right key)
  where graft left (!Empty) = left
        graft left right = Fork left e right'
          where ((!e), right') = leftmost right
        leftmost (!(Fork Empty e r)) = (e, r)
        leftmost (Fork (!l) e r) = (e2, Fork l' e r)
          where ((!e2), l') = leftmost l
enterList t [] = t
enterList Empty (!((!((!e) : res)))) = Fork left e right
  where k = fst e
        left = enterList Empty [e1 | (!e1) <- res, fst e1 < k]
        right = enterList Empty [e1 | (!e1) <- res, fst e1 > k]
enterList (!(Fork left (!e) right)) es = Fork left' e right'
  where k = fst e
        left' = enterList left [e1 | e1 <- es, fst e1 < k]
        right' = enterList right [e1 | (!e1) <- es, fst e1 > k]
updateList t es
  = balance (mergeKey (entries t) (unique (sortKey es)))
  where balance [] = Empty
        balance es = Fork left (es !! m) right
          where left = balance (take m es)
                right = balance (drop (m + 1) es)
                (!m) = length es `div` 2
        unique [] = []
        unique [(!e)] = [e]
        unique ((k1, (!v1)) : (((!k2), v2) : (!res)))
          = if k1 == k2 then unique ((k2, v2) : res) else
              (k1, v1) : unique ((k2, v2) : res)
sortKey (!kvs) = foldr insertKey [] kvs
  where insertKey (!kv) (![]) = [kv]
        insertKey (!(k1, v1)) (((!k2), v2) : res)
          | k1 <= k2 = (k1, v1) : (k2, v2) : res
          | otherwise = (k2, v2) : insertKey (k1, v1) res
mergeKey [] (!kvs) = kvs
mergeKey kvs [] = kvs
mergeKey ((!((!(k1, (!v1))) : (!kvs1)))) ((!((!k2), (!v2))) : kvs2)
  | k1 <= k2 = (k1, v1) : mergeKey kvs1 ((k2, v2) : kvs2)
  | otherwise = (k2, v2) : mergeKey ((k1, v1) : kvs1) kvs2
entries Empty = []
entries (Fork left (!e) right)
  = entries left ++ [e] ++ entries right