module Table where
import Result
 
data Table k v = Empty
               | Fork (Table k v) (k, v) (Table k v)
newTable = Empty
find Empty key = failure "not found"
find (!((!(Fork left (!((!k), v)) right)))) key
  | key < k = find left key
  | key == k = success v
  | key > k = find right key
enter Empty key val = Fork Empty (key, val) Empty
enter (Fork (!left) (k, v) right) key (!val)
  | key < k = Fork (enter left key val) (k, v) right
  | key == k = Fork left (k, v) right
  | key > k = Fork left (k, v) (enter right key val)
update Empty (!key) val = Fork Empty (key, val) Empty
update (Fork (!left) ((!k), (!v)) (!right)) key val
  | key < k = Fork (update left key val) (k, v) right
  | key == k = Fork left (key, val) right
  | key > k = Fork left (k, v) (update right key val)
delete Empty key = Empty
delete (!((!(Fork (!left) (!((!k), (!v))) (!right))))) key
  | key < k = Fork (delete left key) (k, v) right
  | key == k = graft left right
  | key > k = Fork left (k, v) (delete right key)
  where graft left (!Empty) = left
        graft left (!right) = Fork left e right'
          where (!(e, (!right'))) = leftmost right
        leftmost (!(Fork (!Empty) (!e) (!r))) = (e, r)
        leftmost (Fork (!l) e r) = (e2, Fork l' e r)
          where (!((!e2), (!l'))) = leftmost l
enterList t [] = t
enterList Empty ((!e) : res) = Fork left e right
  where (!k) = fst e
        left = enterList Empty [e1 | (!e1) <- res, fst e1 < k]
        right = enterList Empty [e1 | (!e1) <- res, fst e1 > k]
enterList ((!(Fork left (!e) (!right)))) es = Fork left' e right'
  where (!k) = fst e
        (!left') = enterList left [e1 | e1 <- es, fst e1 < k]
        right' = enterList right [e1 | (!e1) <- es, fst e1 > k]
updateList t es
  = balance (mergeKey (entries t) (unique (sortKey es)))
  where balance [] = Empty
        balance es = Fork left (es !! m) right
          where (!left) = balance (take m es)
                (!right) = balance (drop (m + 1) es)
                m = length es `div` 2
        unique [] = []
        unique (![e]) = [e]
        unique ((!((!(k1, v1)) : ((!(k2, (!v2))) : res))))
          = if k1 == k2 then unique ((k2, v2) : res) else
              (k1, v1) : unique ((k2, v2) : res)
sortKey kvs = foldr insertKey [] kvs
  where insertKey (!kv) (![]) = [kv]
        insertKey ((!k1), (!v1)) ((!((k2, v2) : res)))
          | k1 <= k2 = (k1, v1) : (k2, v2) : res
          | otherwise = (k2, v2) : insertKey (k1, v1) res
mergeKey [] (!kvs) = kvs
mergeKey kvs (![]) = kvs
mergeKey (((!k1), (!v1)) : kvs1) (!((!((k2, (!v2)) : kvs2))))
  | k1 <= k2 = (k1, v1) : mergeKey kvs1 ((k2, v2) : kvs2)
  | otherwise = (k2, v2) : mergeKey ((k1, v1) : kvs1) kvs2
entries (!Empty) = []
entries (Fork (!left) e (!right))
  = entries left ++ [e] ++ entries right