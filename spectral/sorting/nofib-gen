HC = /h/ywang30/.stack/programs/x86_64-linux/ghc-gmp4-7.8.4/bin/ghc
HC_OPTS = -XBangPatterns -O2 -funbox-strict-fields -Rghc-timing -H32m -hisuf hi -rtsopts
RUNTEST_OPTS = -ghc-timing
==nofib== sorting: time to compile Sort follows...
/h/ywang30/.stack/programs/x86_64-linux/ghc-gmp4-7.8.4/bin/ghc -XBangPatterns -O2 -funbox-strict-fields -Rghc-timing -H32m -hisuf hi -rtsopts -c Sort.hs -o Sort.o
<<ghc: 257502472 bytes, 60 GCs, 5620098/10469480 avg/max bytes residency (4 samples), 32M in use, 0.00 INIT (0.00 elapsed), 0.28 MUT (0.30 elapsed), 0.18 GC (0.18 elapsed) :ghc>>
==nofib== sorting: size of Sort.o follows...
   text	   data	    bss	    dec	    hex	filename
  20760	    360	      0	  21120	   5280	Sort.o
==nofib== sorting: time to compile Main follows...
/h/ywang30/.stack/programs/x86_64-linux/ghc-gmp4-7.8.4/bin/ghc -XBangPatterns -O2 -funbox-strict-fields -Rghc-timing -H32m -hisuf hi -rtsopts -c Main.hs -o Main.o
<<ghc: 150080360 bytes, 53 GCs, 8513555/19170080 avg/max bytes residency (5 samples), 43M in use, 0.00 INIT (0.00 elapsed), 0.14 MUT (0.16 elapsed), 0.25 GC (0.25 elapsed) :ghc>>
==nofib== sorting: size of Main.o follows...
   text	   data	    bss	    dec	    hex	filename
   2942	    592	      0	   3534	    dce	Main.o
==nofib== sorting: time to link sorting follows...
<<ghc: 38420448 bytes, 14 GCs, 409392/648688 avg/max bytes residency (2 samples), 30M in use, 0.00 INIT (0.00 elapsed), 0.03 MUT (0.47 elapsed), 0.05 GC (0.05 elapsed) :ghc>>
==nofib== sorting: size of sorting follows...
   text	   data	    bss	    dec	    hex	filename
 843684	  43312	  48776	 935772	  e475c	sorting
==nofib== sorting: time to run sorting follows...
timeout 40s ../../runstdtest/runstdtest  ./sorting -i  Sort.hs -o1 sorting.stdout -o1 sorting.stdout  -ghc-timing     ;   timeout 40s ../../runstdtest/runstdtest  ./sorting -i  Sort.hs -o1 sorting.stdout -o1 sorting.stdout  -ghc-timing     ;   timeout 40s ../../runstdtest/runstdtest  ./sorting -i  Sort.hs -o1 sorting.stdout -o1 sorting.stdout  -ghc-timing     ;   timeout 40s ../../runstdtest/runstdtest  ./sorting -i  Sort.hs -o1 sorting.stdout -o1 sorting.stdout  -ghc-timing     ;

real	0m0.015s
user	0m0.005s
sys	0m0.001s
././sorting < Sort.hs
expected stdout not matched by reality
--- sorting.stdout	2016-03-10 15:01:09.530680000 -0500
+++ /var/tmp/runtest26360.1	2016-03-14 12:42:03.822665016 -0400
@@ -1,124 +1,113 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-						| True   = Branch y t1 (mix l2 r2)
-				  | True   = Branch2 y Tip2 (Twig2 x)
-				  | True   = Branch2 y l (to_tree x r)
-				 | True	   = Branch y l (to_tree x r)
-			       | True		 = Branch y l (to_heap (div2 k) x r)
-			       | odd k		 = Branch y (to_heap (div2 k) x l) r
-			       | x <= y		 = Branch x l (to_heap (div2 k) y r)
-			      | True   = rl : (runsplit [x] xs)
-			      | True   = y : (merge xl ys)
-			      | x <  y = x : (merge xs yl)
-			    | True  = trins [] (reverse rev ++ (y:x:xs)) ys
-			 | True	   = split x lo (y:hi) ys
-	(lo, hi) = partition ((>=) x) xs
-	hi = [ y | y <- xs, y >  x ]
-	lo = [ y | y <- xs, y <= x ]
-	to_tree :: Ord a => a -> Tree a -> Tree a
-	to_tree :: Ord a => a -> Tree2 a -> Tree2 a
-	to_tree x Tip			   = Branch x Tip Tip
-	to_tree x Tip2			   = Twig2 x
-    	to_tree x (Branch y l r) | x <= y  = Branch y (to_tree x l) r
-    	to_tree x (Branch2 y l r) | x <= y = Branch2 y (to_tree x l) r
-    	to_tree x (Twig2 y)	  | x <= y = Branch2 y (Twig2 x) Tip2
-      where
-      where
-    clear (Branch x l r) = x : clear (mix l r)
-    clear :: Ord a => Tree a -> [a]
-    clear Tip	     = []
-    div2 :: Int -> Int
-    div2 k = k `div` 2
-    heap :: Ord a => Int -> [a] -> Tree a
-    heap k (x:xs) = to_heap k x (heap (k+(1::Int)) xs)
-    heap k [] = Tip
-    merge :: Ord a => [a] -> [a] -> [a]
-    merge [] ys = ys
-    merge xl@(x:xs) yl@(y:ys) | x == y = x : y : (merge xs ys)
-    merge xs [] = xs
-    merge_lists (x:xs)   = merge x (merge_lists xs)
-    merge_lists :: Ord a => [[a]] -> [a]
-    merge_lists []	 = []
-    mix :: Ord a => Tree a -> Tree a -> Tree a
-    mix Tip r = r
-    mix l Tip = l
-    mix t1@(Branch x l1 r1) t2@(Branch y l2 r2) | x <= y = Branch x (mix l1 r1) t2
-    mkTree :: Ord a => [a] -> Tree a
-    mkTree :: Ord a => [a] -> Tree2 a
-    mkTree = foldr to_tree Tip
-    mkTree = foldr to_tree Tip2
-    readTree (Branch x l r) = readTree l ++ (x : readTree r)
-    readTree (Branch2 x l r) = readTree l ++ (x : readTree r)
-    readTree (Twig2 x)	     = [x]
-    readTree :: Ord a => Tree a -> [a]
-    readTree :: Ord a => Tree2 a -> [a]
-    readTree Tip	    = []
-    readTree Tip2	     = []
-    runsplit :: Ord a => [a] -> [a] -> [[a]]
-    runsplit []     (x:xs)  = runsplit [x] xs
-    runsplit []     []	    = []
-    runsplit [r]       (x:xs) | x >  r = runsplit [r,x] xs
-    runsplit rl@(r:rs) (x:xs) | x <= r = runsplit (x:rl) xs
-    runsplit run    []	    = [run]
-    split x lo hi (y:ys) | y <= x  = split x (y:lo) hi ys
-    split x lo hi []	 = quickerSort lo ++ (x : quickerSort hi)
-    to_heap :: Ord a => Int -> a -> Tree a -> Tree a
-    to_heap k x (Branch y l r) | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
-    to_heap k x Tip				 = Branch x Tip Tip
-    trins :: Ord a => [a] -> [a] -> [a] -> [a]
-    trins rev (x:xs) (y:ys) | x < y = trins (x:rev) xs (y:ys)
-    trins rev []     (y:ys)	    = trins [] ((reverse rev) ++ [y]) ys
-    trins rev xs     []		    = (reverse rev) ++ xs
-    where
-    where
-  where
-  where
-  where
-  where
-  where
-  where
--- again, as per Meira thesis
--- as per Meira thesis
--- ditto, Meira thesis
--- ditto, Meira thesis
--- tail-recursive, etc., "quicker sort" [as per Meira thesis]
--- the same thing, w/ "partition" [whose implementation I don't trust]
--- try it w/ bushier trees
--- trying various sorts
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
-data Tree a = Tip | Branch a (Tree a) (Tree a) deriving ()
-data Tree2 a = Tip2 | Twig2 a | Branch2 a (Tree2 a) (Tree2 a) deriving ()
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+         
+         
+         
+         
+         
+         
+         
+         
+                  | True = Branch y l (to_tree x r)
+                  | True = Branch2 y Tip2 (Twig2 x)
+                  | True = Branch2 y l (to_tree x r)
+                  | x <= y = Branch y (to_tree x l) r
+                  | x <= y = Branch2 y (Twig2 x) Tip2
+                  | x <= y = Branch2 y (to_tree x l) r
+                to_tree (!x) (!(Branch (!y) l r))
+                to_tree :: Ord a => a -> Tree a -> Tree a
+                to_tree :: Ord a => a -> Tree2 a -> Tree2 a
+                to_tree x (!Tip2) = Twig2 x
+                to_tree x (Branch2 y l r)
+                to_tree x (Twig2 y)
+                to_tree x Tip = Branch x Tip Tip
+             | Branch2 a (Tree2 a) (Tree2 a)
+             | Twig2 a
+            | Branch a (Tree a) (Tree a)
+          where  
+          where  
+          | True = Branch y l (to_heap (div2 k) x r)
+          | True = Branch y t1 (mix l2 r2)
+          | True = rl : (runsplit [x] xs)
+          | True = split x lo (y : hi) ys
+          | True = trins [] (reverse rev ++ (y : x : xs)) ys
+          | True = y : (merge xl ys)
+          | odd k = Branch y (to_heap (div2 k) x l) r
+          | x < y = trins (x : rev) xs (y : ys)
+          | x < y = x : (merge xs yl)
+          | x <= r = runsplit (x : rl) xs
+          | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
+          | x <= y = Branch x (mix l1 r1) t2
+          | x <= y = Branch x l (to_heap (div2 k) y r)
+          | x == y = x : y : (merge xs ys)
+          | y <= x = split x (y : lo) hi ys
+        clear (Branch x l r) = x : clear (mix l r)
+        clear :: Ord a => Tree a -> [a]
+        clear Tip = []
+        div2 :: Int -> Int
+        div2 k = k `div` 2
+        heap (!k) (!(x : xs)) = to_heap k x (heap (k + (1 :: Int)) xs)
+        heap :: Ord a => Int -> [a] -> Tree a
+        heap k [] = Tip
+        hi = [y | y <- xs, y > x]
+        merge (!xl@(x : xs)) yl@(y : ys)
+        merge (!xs) [] = xs
+        merge :: Ord a => [a] -> [a] -> [a]
+        merge [] ys = ys
+        merge_lists (x : xs) = merge x (merge_lists xs)
+        merge_lists :: Ord a => [[a]] -> [a]
+        merge_lists [] = []
+        mix :: Ord a => Tree a -> Tree a -> Tree a
+        mix Tip r = r
+        mix l Tip = l
+        mix t1@(Branch (!x) l1 r1) t2@(Branch y (!l2) r2)
+        mkTree :: Ord a => [a] -> Tree a
+        mkTree :: Ord a => [a] -> Tree2 a
+        mkTree = foldr to_tree Tip
+        mkTree = foldr to_tree Tip2
+        readTree (!Tip) = []
+        readTree ((!(Branch2 x l r))) = readTree l ++ (x : readTree r)
+        readTree (Branch x l r) = readTree l ++ (x : readTree r)
+        readTree (Twig2 x) = [x]
+        readTree :: Ord a => Tree a -> [a]
+        readTree :: Ord a => Tree2 a -> [a]
+        readTree Tip2 = []
+        runsplit :: Ord a => [a] -> [a] -> [[a]]
+        runsplit [] (!(x : xs)) = runsplit [x] xs
+        runsplit [] [] = []
+        runsplit [r] (!(x : xs)) | x > r = runsplit [r, x] xs
+        runsplit rl@(r : rs) ((!x) : xs)
+        runsplit run [] = [run]
+        split (!x) lo hi (y : ys)
+        to_heap (!k) (!x) (Branch y l r)
+        to_heap :: Ord a => Int -> a -> Tree a -> Tree a
+        to_heap k x Tip = Branch x Tip Tip
+        trins :: Ord a => [a] -> [a] -> [a] -> [a]
+        trins rev (x : xs) (y : ys)
+        trins rev [] (!(y : ys)) = trins [] ((reverse rev) ++ [y]) ys
+        trins rev xs [] = (reverse rev) ++ xs
+  where  
+  where  
+  where  
+  where  
+  where  
+  where (lo, hi) = partition ((>=) x) xs
+  where lo = [y | y <- xs, y <= x]
+  where split x lo hi [] = quickerSort lo ++ (x : quickerSort hi)
+data Tree a = Tip
+data Tree2 a = Tip2
 heapSort :: Ord a => [a] -> [a]
-heapSort xs = clear (heap (0::Int) xs)
+heapSort xs = clear (heap (0 :: Int) xs)
 import Data.List (partition)
-insertSort (x:xs)   = trins [] [x] xs
+insertSort (x : xs) = trins [] [x] xs
 insertSort :: Ord a => [a] -> [a]
-insertSort []	    = []
+insertSort [] = []
 mergeSort :: Ord a => [a] -> [a]
@@ -126,12 +115,12 @@
 module Sort where
-quickSort (x:xs) = (quickSort lo) ++ (x : quickSort hi)
+quickSort (x : xs) = (quickSort lo) ++ (x : quickSort hi)
 quickSort :: Ord a => [a] -> [a]
-quickSort []	 = []
-quickSort2 (x:xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
+quickSort [] = []
+quickSort2 (x : xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
 quickSort2 :: Ord a => [a] -> [a]
-quickSort2 []	 = []
-quickerSort (x:xs)  = split x [] [] xs
+quickSort2 [] = []
+quickerSort (x : xs) = split x [] [] xs
 quickerSort :: Ord a => [a] -> [a]
-quickerSort []	    = []
-quickerSort [x]	    = [x]
+quickerSort [] = []
+quickerSort [x] = [x]
 treeSort :: Ord a => [a] -> [a]

real	0m0.007s
user	0m0.003s
sys	0m0.004s
././sorting < Sort.hs
expected stdout not matched by reality
--- sorting.stdout	2016-03-10 15:01:09.530680000 -0500
+++ /var/tmp/runtest26491.1	2016-03-14 12:42:03.863664914 -0400
@@ -1,124 +1,113 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-						| True   = Branch y t1 (mix l2 r2)
-				  | True   = Branch2 y Tip2 (Twig2 x)
-				  | True   = Branch2 y l (to_tree x r)
-				 | True	   = Branch y l (to_tree x r)
-			       | True		 = Branch y l (to_heap (div2 k) x r)
-			       | odd k		 = Branch y (to_heap (div2 k) x l) r
-			       | x <= y		 = Branch x l (to_heap (div2 k) y r)
-			      | True   = rl : (runsplit [x] xs)
-			      | True   = y : (merge xl ys)
-			      | x <  y = x : (merge xs yl)
-			    | True  = trins [] (reverse rev ++ (y:x:xs)) ys
-			 | True	   = split x lo (y:hi) ys
-	(lo, hi) = partition ((>=) x) xs
-	hi = [ y | y <- xs, y >  x ]
-	lo = [ y | y <- xs, y <= x ]
-	to_tree :: Ord a => a -> Tree a -> Tree a
-	to_tree :: Ord a => a -> Tree2 a -> Tree2 a
-	to_tree x Tip			   = Branch x Tip Tip
-	to_tree x Tip2			   = Twig2 x
-    	to_tree x (Branch y l r) | x <= y  = Branch y (to_tree x l) r
-    	to_tree x (Branch2 y l r) | x <= y = Branch2 y (to_tree x l) r
-    	to_tree x (Twig2 y)	  | x <= y = Branch2 y (Twig2 x) Tip2
-      where
-      where
-    clear (Branch x l r) = x : clear (mix l r)
-    clear :: Ord a => Tree a -> [a]
-    clear Tip	     = []
-    div2 :: Int -> Int
-    div2 k = k `div` 2
-    heap :: Ord a => Int -> [a] -> Tree a
-    heap k (x:xs) = to_heap k x (heap (k+(1::Int)) xs)
-    heap k [] = Tip
-    merge :: Ord a => [a] -> [a] -> [a]
-    merge [] ys = ys
-    merge xl@(x:xs) yl@(y:ys) | x == y = x : y : (merge xs ys)
-    merge xs [] = xs
-    merge_lists (x:xs)   = merge x (merge_lists xs)
-    merge_lists :: Ord a => [[a]] -> [a]
-    merge_lists []	 = []
-    mix :: Ord a => Tree a -> Tree a -> Tree a
-    mix Tip r = r
-    mix l Tip = l
-    mix t1@(Branch x l1 r1) t2@(Branch y l2 r2) | x <= y = Branch x (mix l1 r1) t2
-    mkTree :: Ord a => [a] -> Tree a
-    mkTree :: Ord a => [a] -> Tree2 a
-    mkTree = foldr to_tree Tip
-    mkTree = foldr to_tree Tip2
-    readTree (Branch x l r) = readTree l ++ (x : readTree r)
-    readTree (Branch2 x l r) = readTree l ++ (x : readTree r)
-    readTree (Twig2 x)	     = [x]
-    readTree :: Ord a => Tree a -> [a]
-    readTree :: Ord a => Tree2 a -> [a]
-    readTree Tip	    = []
-    readTree Tip2	     = []
-    runsplit :: Ord a => [a] -> [a] -> [[a]]
-    runsplit []     (x:xs)  = runsplit [x] xs
-    runsplit []     []	    = []
-    runsplit [r]       (x:xs) | x >  r = runsplit [r,x] xs
-    runsplit rl@(r:rs) (x:xs) | x <= r = runsplit (x:rl) xs
-    runsplit run    []	    = [run]
-    split x lo hi (y:ys) | y <= x  = split x (y:lo) hi ys
-    split x lo hi []	 = quickerSort lo ++ (x : quickerSort hi)
-    to_heap :: Ord a => Int -> a -> Tree a -> Tree a
-    to_heap k x (Branch y l r) | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
-    to_heap k x Tip				 = Branch x Tip Tip
-    trins :: Ord a => [a] -> [a] -> [a] -> [a]
-    trins rev (x:xs) (y:ys) | x < y = trins (x:rev) xs (y:ys)
-    trins rev []     (y:ys)	    = trins [] ((reverse rev) ++ [y]) ys
-    trins rev xs     []		    = (reverse rev) ++ xs
-    where
-    where
-  where
-  where
-  where
-  where
-  where
-  where
--- again, as per Meira thesis
--- as per Meira thesis
--- ditto, Meira thesis
--- ditto, Meira thesis
--- tail-recursive, etc., "quicker sort" [as per Meira thesis]
--- the same thing, w/ "partition" [whose implementation I don't trust]
--- try it w/ bushier trees
--- trying various sorts
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
-data Tree a = Tip | Branch a (Tree a) (Tree a) deriving ()
-data Tree2 a = Tip2 | Twig2 a | Branch2 a (Tree2 a) (Tree2 a) deriving ()
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+         
+         
+         
+         
+         
+         
+         
+         
+                  | True = Branch y l (to_tree x r)
+                  | True = Branch2 y Tip2 (Twig2 x)
+                  | True = Branch2 y l (to_tree x r)
+                  | x <= y = Branch y (to_tree x l) r
+                  | x <= y = Branch2 y (Twig2 x) Tip2
+                  | x <= y = Branch2 y (to_tree x l) r
+                to_tree (!x) (!(Branch (!y) l r))
+                to_tree :: Ord a => a -> Tree a -> Tree a
+                to_tree :: Ord a => a -> Tree2 a -> Tree2 a
+                to_tree x (!Tip2) = Twig2 x
+                to_tree x (Branch2 y l r)
+                to_tree x (Twig2 y)
+                to_tree x Tip = Branch x Tip Tip
+             | Branch2 a (Tree2 a) (Tree2 a)
+             | Twig2 a
+            | Branch a (Tree a) (Tree a)
+          where  
+          where  
+          | True = Branch y l (to_heap (div2 k) x r)
+          | True = Branch y t1 (mix l2 r2)
+          | True = rl : (runsplit [x] xs)
+          | True = split x lo (y : hi) ys
+          | True = trins [] (reverse rev ++ (y : x : xs)) ys
+          | True = y : (merge xl ys)
+          | odd k = Branch y (to_heap (div2 k) x l) r
+          | x < y = trins (x : rev) xs (y : ys)
+          | x < y = x : (merge xs yl)
+          | x <= r = runsplit (x : rl) xs
+          | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
+          | x <= y = Branch x (mix l1 r1) t2
+          | x <= y = Branch x l (to_heap (div2 k) y r)
+          | x == y = x : y : (merge xs ys)
+          | y <= x = split x (y : lo) hi ys
+        clear (Branch x l r) = x : clear (mix l r)
+        clear :: Ord a => Tree a -> [a]
+        clear Tip = []
+        div2 :: Int -> Int
+        div2 k = k `div` 2
+        heap (!k) (!(x : xs)) = to_heap k x (heap (k + (1 :: Int)) xs)
+        heap :: Ord a => Int -> [a] -> Tree a
+        heap k [] = Tip
+        hi = [y | y <- xs, y > x]
+        merge (!xl@(x : xs)) yl@(y : ys)
+        merge (!xs) [] = xs
+        merge :: Ord a => [a] -> [a] -> [a]
+        merge [] ys = ys
+        merge_lists (x : xs) = merge x (merge_lists xs)
+        merge_lists :: Ord a => [[a]] -> [a]
+        merge_lists [] = []
+        mix :: Ord a => Tree a -> Tree a -> Tree a
+        mix Tip r = r
+        mix l Tip = l
+        mix t1@(Branch (!x) l1 r1) t2@(Branch y (!l2) r2)
+        mkTree :: Ord a => [a] -> Tree a
+        mkTree :: Ord a => [a] -> Tree2 a
+        mkTree = foldr to_tree Tip
+        mkTree = foldr to_tree Tip2
+        readTree (!Tip) = []
+        readTree ((!(Branch2 x l r))) = readTree l ++ (x : readTree r)
+        readTree (Branch x l r) = readTree l ++ (x : readTree r)
+        readTree (Twig2 x) = [x]
+        readTree :: Ord a => Tree a -> [a]
+        readTree :: Ord a => Tree2 a -> [a]
+        readTree Tip2 = []
+        runsplit :: Ord a => [a] -> [a] -> [[a]]
+        runsplit [] (!(x : xs)) = runsplit [x] xs
+        runsplit [] [] = []
+        runsplit [r] (!(x : xs)) | x > r = runsplit [r, x] xs
+        runsplit rl@(r : rs) ((!x) : xs)
+        runsplit run [] = [run]
+        split (!x) lo hi (y : ys)
+        to_heap (!k) (!x) (Branch y l r)
+        to_heap :: Ord a => Int -> a -> Tree a -> Tree a
+        to_heap k x Tip = Branch x Tip Tip
+        trins :: Ord a => [a] -> [a] -> [a] -> [a]
+        trins rev (x : xs) (y : ys)
+        trins rev [] (!(y : ys)) = trins [] ((reverse rev) ++ [y]) ys
+        trins rev xs [] = (reverse rev) ++ xs
+  where  
+  where  
+  where  
+  where  
+  where  
+  where (lo, hi) = partition ((>=) x) xs
+  where lo = [y | y <- xs, y <= x]
+  where split x lo hi [] = quickerSort lo ++ (x : quickerSort hi)
+data Tree a = Tip
+data Tree2 a = Tip2
 heapSort :: Ord a => [a] -> [a]
-heapSort xs = clear (heap (0::Int) xs)
+heapSort xs = clear (heap (0 :: Int) xs)
 import Data.List (partition)
-insertSort (x:xs)   = trins [] [x] xs
+insertSort (x : xs) = trins [] [x] xs
 insertSort :: Ord a => [a] -> [a]
-insertSort []	    = []
+insertSort [] = []
 mergeSort :: Ord a => [a] -> [a]
@@ -126,12 +115,12 @@
 module Sort where
-quickSort (x:xs) = (quickSort lo) ++ (x : quickSort hi)
+quickSort (x : xs) = (quickSort lo) ++ (x : quickSort hi)
 quickSort :: Ord a => [a] -> [a]
-quickSort []	 = []
-quickSort2 (x:xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
+quickSort [] = []
+quickSort2 (x : xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
 quickSort2 :: Ord a => [a] -> [a]
-quickSort2 []	 = []
-quickerSort (x:xs)  = split x [] [] xs
+quickSort2 [] = []
+quickerSort (x : xs) = split x [] [] xs
 quickerSort :: Ord a => [a] -> [a]
-quickerSort []	    = []
-quickerSort [x]	    = [x]
+quickerSort [] = []
+quickerSort [x] = [x]
 treeSort :: Ord a => [a] -> [a]

real	0m0.008s
user	0m0.002s
sys	0m0.004s
././sorting < Sort.hs
expected stdout not matched by reality
--- sorting.stdout	2016-03-10 15:01:09.530680000 -0500
+++ /var/tmp/runtest26574.1	2016-03-14 12:42:03.907664806 -0400
@@ -1,124 +1,113 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-						| True   = Branch y t1 (mix l2 r2)
-				  | True   = Branch2 y Tip2 (Twig2 x)
-				  | True   = Branch2 y l (to_tree x r)
-				 | True	   = Branch y l (to_tree x r)
-			       | True		 = Branch y l (to_heap (div2 k) x r)
-			       | odd k		 = Branch y (to_heap (div2 k) x l) r
-			       | x <= y		 = Branch x l (to_heap (div2 k) y r)
-			      | True   = rl : (runsplit [x] xs)
-			      | True   = y : (merge xl ys)
-			      | x <  y = x : (merge xs yl)
-			    | True  = trins [] (reverse rev ++ (y:x:xs)) ys
-			 | True	   = split x lo (y:hi) ys
-	(lo, hi) = partition ((>=) x) xs
-	hi = [ y | y <- xs, y >  x ]
-	lo = [ y | y <- xs, y <= x ]
-	to_tree :: Ord a => a -> Tree a -> Tree a
-	to_tree :: Ord a => a -> Tree2 a -> Tree2 a
-	to_tree x Tip			   = Branch x Tip Tip
-	to_tree x Tip2			   = Twig2 x
-    	to_tree x (Branch y l r) | x <= y  = Branch y (to_tree x l) r
-    	to_tree x (Branch2 y l r) | x <= y = Branch2 y (to_tree x l) r
-    	to_tree x (Twig2 y)	  | x <= y = Branch2 y (Twig2 x) Tip2
-      where
-      where
-    clear (Branch x l r) = x : clear (mix l r)
-    clear :: Ord a => Tree a -> [a]
-    clear Tip	     = []
-    div2 :: Int -> Int
-    div2 k = k `div` 2
-    heap :: Ord a => Int -> [a] -> Tree a
-    heap k (x:xs) = to_heap k x (heap (k+(1::Int)) xs)
-    heap k [] = Tip
-    merge :: Ord a => [a] -> [a] -> [a]
-    merge [] ys = ys
-    merge xl@(x:xs) yl@(y:ys) | x == y = x : y : (merge xs ys)
-    merge xs [] = xs
-    merge_lists (x:xs)   = merge x (merge_lists xs)
-    merge_lists :: Ord a => [[a]] -> [a]
-    merge_lists []	 = []
-    mix :: Ord a => Tree a -> Tree a -> Tree a
-    mix Tip r = r
-    mix l Tip = l
-    mix t1@(Branch x l1 r1) t2@(Branch y l2 r2) | x <= y = Branch x (mix l1 r1) t2
-    mkTree :: Ord a => [a] -> Tree a
-    mkTree :: Ord a => [a] -> Tree2 a
-    mkTree = foldr to_tree Tip
-    mkTree = foldr to_tree Tip2
-    readTree (Branch x l r) = readTree l ++ (x : readTree r)
-    readTree (Branch2 x l r) = readTree l ++ (x : readTree r)
-    readTree (Twig2 x)	     = [x]
-    readTree :: Ord a => Tree a -> [a]
-    readTree :: Ord a => Tree2 a -> [a]
-    readTree Tip	    = []
-    readTree Tip2	     = []
-    runsplit :: Ord a => [a] -> [a] -> [[a]]
-    runsplit []     (x:xs)  = runsplit [x] xs
-    runsplit []     []	    = []
-    runsplit [r]       (x:xs) | x >  r = runsplit [r,x] xs
-    runsplit rl@(r:rs) (x:xs) | x <= r = runsplit (x:rl) xs
-    runsplit run    []	    = [run]
-    split x lo hi (y:ys) | y <= x  = split x (y:lo) hi ys
-    split x lo hi []	 = quickerSort lo ++ (x : quickerSort hi)
-    to_heap :: Ord a => Int -> a -> Tree a -> Tree a
-    to_heap k x (Branch y l r) | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
-    to_heap k x Tip				 = Branch x Tip Tip
-    trins :: Ord a => [a] -> [a] -> [a] -> [a]
-    trins rev (x:xs) (y:ys) | x < y = trins (x:rev) xs (y:ys)
-    trins rev []     (y:ys)	    = trins [] ((reverse rev) ++ [y]) ys
-    trins rev xs     []		    = (reverse rev) ++ xs
-    where
-    where
-  where
-  where
-  where
-  where
-  where
-  where
--- again, as per Meira thesis
--- as per Meira thesis
--- ditto, Meira thesis
--- ditto, Meira thesis
--- tail-recursive, etc., "quicker sort" [as per Meira thesis]
--- the same thing, w/ "partition" [whose implementation I don't trust]
--- try it w/ bushier trees
--- trying various sorts
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
-data Tree a = Tip | Branch a (Tree a) (Tree a) deriving ()
-data Tree2 a = Tip2 | Twig2 a | Branch2 a (Tree2 a) (Tree2 a) deriving ()
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+         
+         
+         
+         
+         
+         
+         
+         
+                  | True = Branch y l (to_tree x r)
+                  | True = Branch2 y Tip2 (Twig2 x)
+                  | True = Branch2 y l (to_tree x r)
+                  | x <= y = Branch y (to_tree x l) r
+                  | x <= y = Branch2 y (Twig2 x) Tip2
+                  | x <= y = Branch2 y (to_tree x l) r
+                to_tree (!x) (!(Branch (!y) l r))
+                to_tree :: Ord a => a -> Tree a -> Tree a
+                to_tree :: Ord a => a -> Tree2 a -> Tree2 a
+                to_tree x (!Tip2) = Twig2 x
+                to_tree x (Branch2 y l r)
+                to_tree x (Twig2 y)
+                to_tree x Tip = Branch x Tip Tip
+             | Branch2 a (Tree2 a) (Tree2 a)
+             | Twig2 a
+            | Branch a (Tree a) (Tree a)
+          where  
+          where  
+          | True = Branch y l (to_heap (div2 k) x r)
+          | True = Branch y t1 (mix l2 r2)
+          | True = rl : (runsplit [x] xs)
+          | True = split x lo (y : hi) ys
+          | True = trins [] (reverse rev ++ (y : x : xs)) ys
+          | True = y : (merge xl ys)
+          | odd k = Branch y (to_heap (div2 k) x l) r
+          | x < y = trins (x : rev) xs (y : ys)
+          | x < y = x : (merge xs yl)
+          | x <= r = runsplit (x : rl) xs
+          | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
+          | x <= y = Branch x (mix l1 r1) t2
+          | x <= y = Branch x l (to_heap (div2 k) y r)
+          | x == y = x : y : (merge xs ys)
+          | y <= x = split x (y : lo) hi ys
+        clear (Branch x l r) = x : clear (mix l r)
+        clear :: Ord a => Tree a -> [a]
+        clear Tip = []
+        div2 :: Int -> Int
+        div2 k = k `div` 2
+        heap (!k) (!(x : xs)) = to_heap k x (heap (k + (1 :: Int)) xs)
+        heap :: Ord a => Int -> [a] -> Tree a
+        heap k [] = Tip
+        hi = [y | y <- xs, y > x]
+        merge (!xl@(x : xs)) yl@(y : ys)
+        merge (!xs) [] = xs
+        merge :: Ord a => [a] -> [a] -> [a]
+        merge [] ys = ys
+        merge_lists (x : xs) = merge x (merge_lists xs)
+        merge_lists :: Ord a => [[a]] -> [a]
+        merge_lists [] = []
+        mix :: Ord a => Tree a -> Tree a -> Tree a
+        mix Tip r = r
+        mix l Tip = l
+        mix t1@(Branch (!x) l1 r1) t2@(Branch y (!l2) r2)
+        mkTree :: Ord a => [a] -> Tree a
+        mkTree :: Ord a => [a] -> Tree2 a
+        mkTree = foldr to_tree Tip
+        mkTree = foldr to_tree Tip2
+        readTree (!Tip) = []
+        readTree ((!(Branch2 x l r))) = readTree l ++ (x : readTree r)
+        readTree (Branch x l r) = readTree l ++ (x : readTree r)
+        readTree (Twig2 x) = [x]
+        readTree :: Ord a => Tree a -> [a]
+        readTree :: Ord a => Tree2 a -> [a]
+        readTree Tip2 = []
+        runsplit :: Ord a => [a] -> [a] -> [[a]]
+        runsplit [] (!(x : xs)) = runsplit [x] xs
+        runsplit [] [] = []
+        runsplit [r] (!(x : xs)) | x > r = runsplit [r, x] xs
+        runsplit rl@(r : rs) ((!x) : xs)
+        runsplit run [] = [run]
+        split (!x) lo hi (y : ys)
+        to_heap (!k) (!x) (Branch y l r)
+        to_heap :: Ord a => Int -> a -> Tree a -> Tree a
+        to_heap k x Tip = Branch x Tip Tip
+        trins :: Ord a => [a] -> [a] -> [a] -> [a]
+        trins rev (x : xs) (y : ys)
+        trins rev [] (!(y : ys)) = trins [] ((reverse rev) ++ [y]) ys
+        trins rev xs [] = (reverse rev) ++ xs
+  where  
+  where  
+  where  
+  where  
+  where  
+  where (lo, hi) = partition ((>=) x) xs
+  where lo = [y | y <- xs, y <= x]
+  where split x lo hi [] = quickerSort lo ++ (x : quickerSort hi)
+data Tree a = Tip
+data Tree2 a = Tip2
 heapSort :: Ord a => [a] -> [a]
-heapSort xs = clear (heap (0::Int) xs)
+heapSort xs = clear (heap (0 :: Int) xs)
 import Data.List (partition)
-insertSort (x:xs)   = trins [] [x] xs
+insertSort (x : xs) = trins [] [x] xs
 insertSort :: Ord a => [a] -> [a]
-insertSort []	    = []
+insertSort [] = []
 mergeSort :: Ord a => [a] -> [a]
@@ -126,12 +115,12 @@
 module Sort where
-quickSort (x:xs) = (quickSort lo) ++ (x : quickSort hi)
+quickSort (x : xs) = (quickSort lo) ++ (x : quickSort hi)
 quickSort :: Ord a => [a] -> [a]
-quickSort []	 = []
-quickSort2 (x:xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
+quickSort [] = []
+quickSort2 (x : xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
 quickSort2 :: Ord a => [a] -> [a]
-quickSort2 []	 = []
-quickerSort (x:xs)  = split x [] [] xs
+quickSort2 [] = []
+quickerSort (x : xs) = split x [] [] xs
 quickerSort :: Ord a => [a] -> [a]
-quickerSort []	    = []
-quickerSort [x]	    = [x]
+quickerSort [] = []
+quickerSort [x] = [x]
 treeSort :: Ord a => [a] -> [a]

real	0m0.007s
user	0m0.005s
sys	0m0.002s
././sorting < Sort.hs
expected stdout not matched by reality
--- sorting.stdout	2016-03-10 15:01:09.530680000 -0500
+++ /var/tmp/runtest26663.1	2016-03-14 12:42:03.951664697 -0400
@@ -1,124 +1,113 @@
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-						| True   = Branch y t1 (mix l2 r2)
-				  | True   = Branch2 y Tip2 (Twig2 x)
-				  | True   = Branch2 y l (to_tree x r)
-				 | True	   = Branch y l (to_tree x r)
-			       | True		 = Branch y l (to_heap (div2 k) x r)
-			       | odd k		 = Branch y (to_heap (div2 k) x l) r
-			       | x <= y		 = Branch x l (to_heap (div2 k) y r)
-			      | True   = rl : (runsplit [x] xs)
-			      | True   = y : (merge xl ys)
-			      | x <  y = x : (merge xs yl)
-			    | True  = trins [] (reverse rev ++ (y:x:xs)) ys
-			 | True	   = split x lo (y:hi) ys
-	(lo, hi) = partition ((>=) x) xs
-	hi = [ y | y <- xs, y >  x ]
-	lo = [ y | y <- xs, y <= x ]
-	to_tree :: Ord a => a -> Tree a -> Tree a
-	to_tree :: Ord a => a -> Tree2 a -> Tree2 a
-	to_tree x Tip			   = Branch x Tip Tip
-	to_tree x Tip2			   = Twig2 x
-    	to_tree x (Branch y l r) | x <= y  = Branch y (to_tree x l) r
-    	to_tree x (Branch2 y l r) | x <= y = Branch2 y (to_tree x l) r
-    	to_tree x (Twig2 y)	  | x <= y = Branch2 y (Twig2 x) Tip2
-      where
-      where
-    clear (Branch x l r) = x : clear (mix l r)
-    clear :: Ord a => Tree a -> [a]
-    clear Tip	     = []
-    div2 :: Int -> Int
-    div2 k = k `div` 2
-    heap :: Ord a => Int -> [a] -> Tree a
-    heap k (x:xs) = to_heap k x (heap (k+(1::Int)) xs)
-    heap k [] = Tip
-    merge :: Ord a => [a] -> [a] -> [a]
-    merge [] ys = ys
-    merge xl@(x:xs) yl@(y:ys) | x == y = x : y : (merge xs ys)
-    merge xs [] = xs
-    merge_lists (x:xs)   = merge x (merge_lists xs)
-    merge_lists :: Ord a => [[a]] -> [a]
-    merge_lists []	 = []
-    mix :: Ord a => Tree a -> Tree a -> Tree a
-    mix Tip r = r
-    mix l Tip = l
-    mix t1@(Branch x l1 r1) t2@(Branch y l2 r2) | x <= y = Branch x (mix l1 r1) t2
-    mkTree :: Ord a => [a] -> Tree a
-    mkTree :: Ord a => [a] -> Tree2 a
-    mkTree = foldr to_tree Tip
-    mkTree = foldr to_tree Tip2
-    readTree (Branch x l r) = readTree l ++ (x : readTree r)
-    readTree (Branch2 x l r) = readTree l ++ (x : readTree r)
-    readTree (Twig2 x)	     = [x]
-    readTree :: Ord a => Tree a -> [a]
-    readTree :: Ord a => Tree2 a -> [a]
-    readTree Tip	    = []
-    readTree Tip2	     = []
-    runsplit :: Ord a => [a] -> [a] -> [[a]]
-    runsplit []     (x:xs)  = runsplit [x] xs
-    runsplit []     []	    = []
-    runsplit [r]       (x:xs) | x >  r = runsplit [r,x] xs
-    runsplit rl@(r:rs) (x:xs) | x <= r = runsplit (x:rl) xs
-    runsplit run    []	    = [run]
-    split x lo hi (y:ys) | y <= x  = split x (y:lo) hi ys
-    split x lo hi []	 = quickerSort lo ++ (x : quickerSort hi)
-    to_heap :: Ord a => Int -> a -> Tree a -> Tree a
-    to_heap k x (Branch y l r) | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
-    to_heap k x Tip				 = Branch x Tip Tip
-    trins :: Ord a => [a] -> [a] -> [a] -> [a]
-    trins rev (x:xs) (y:ys) | x < y = trins (x:rev) xs (y:ys)
-    trins rev []     (y:ys)	    = trins [] ((reverse rev) ++ [y]) ys
-    trins rev xs     []		    = (reverse rev) ++ xs
-    where
-    where
-  where
-  where
-  where
-  where
-  where
-  where
--- again, as per Meira thesis
--- as per Meira thesis
--- ditto, Meira thesis
--- ditto, Meira thesis
--- tail-recursive, etc., "quicker sort" [as per Meira thesis]
--- the same thing, w/ "partition" [whose implementation I don't trust]
--- try it w/ bushier trees
--- trying various sorts
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
--------------------------------------------------------------
-data Tree a = Tip | Branch a (Tree a) (Tree a) deriving ()
-data Tree2 a = Tip2 | Twig2 a | Branch2 a (Tree2 a) (Tree2 a) deriving ()
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+         
+         
+         
+         
+         
+         
+         
+         
+                  | True = Branch y l (to_tree x r)
+                  | True = Branch2 y Tip2 (Twig2 x)
+                  | True = Branch2 y l (to_tree x r)
+                  | x <= y = Branch y (to_tree x l) r
+                  | x <= y = Branch2 y (Twig2 x) Tip2
+                  | x <= y = Branch2 y (to_tree x l) r
+                to_tree (!x) (!(Branch (!y) l r))
+                to_tree :: Ord a => a -> Tree a -> Tree a
+                to_tree :: Ord a => a -> Tree2 a -> Tree2 a
+                to_tree x (!Tip2) = Twig2 x
+                to_tree x (Branch2 y l r)
+                to_tree x (Twig2 y)
+                to_tree x Tip = Branch x Tip Tip
+             | Branch2 a (Tree2 a) (Tree2 a)
+             | Twig2 a
+            | Branch a (Tree a) (Tree a)
+          where  
+          where  
+          | True = Branch y l (to_heap (div2 k) x r)
+          | True = Branch y t1 (mix l2 r2)
+          | True = rl : (runsplit [x] xs)
+          | True = split x lo (y : hi) ys
+          | True = trins [] (reverse rev ++ (y : x : xs)) ys
+          | True = y : (merge xl ys)
+          | odd k = Branch y (to_heap (div2 k) x l) r
+          | x < y = trins (x : rev) xs (y : ys)
+          | x < y = x : (merge xs yl)
+          | x <= r = runsplit (x : rl) xs
+          | x <= y && odd k = Branch x (to_heap (div2 k) y l) r
+          | x <= y = Branch x (mix l1 r1) t2
+          | x <= y = Branch x l (to_heap (div2 k) y r)
+          | x == y = x : y : (merge xs ys)
+          | y <= x = split x (y : lo) hi ys
+        clear (Branch x l r) = x : clear (mix l r)
+        clear :: Ord a => Tree a -> [a]
+        clear Tip = []
+        div2 :: Int -> Int
+        div2 k = k `div` 2
+        heap (!k) (!(x : xs)) = to_heap k x (heap (k + (1 :: Int)) xs)
+        heap :: Ord a => Int -> [a] -> Tree a
+        heap k [] = Tip
+        hi = [y | y <- xs, y > x]
+        merge (!xl@(x : xs)) yl@(y : ys)
+        merge (!xs) [] = xs
+        merge :: Ord a => [a] -> [a] -> [a]
+        merge [] ys = ys
+        merge_lists (x : xs) = merge x (merge_lists xs)
+        merge_lists :: Ord a => [[a]] -> [a]
+        merge_lists [] = []
+        mix :: Ord a => Tree a -> Tree a -> Tree a
+        mix Tip r = r
+        mix l Tip = l
+        mix t1@(Branch (!x) l1 r1) t2@(Branch y (!l2) r2)
+        mkTree :: Ord a => [a] -> Tree a
+        mkTree :: Ord a => [a] -> Tree2 a
+        mkTree = foldr to_tree Tip
+        mkTree = foldr to_tree Tip2
+        readTree (!Tip) = []
+        readTree ((!(Branch2 x l r))) = readTree l ++ (x : readTree r)
+        readTree (Branch x l r) = readTree l ++ (x : readTree r)
+        readTree (Twig2 x) = [x]
+        readTree :: Ord a => Tree a -> [a]
+        readTree :: Ord a => Tree2 a -> [a]
+        readTree Tip2 = []
+        runsplit :: Ord a => [a] -> [a] -> [[a]]
+        runsplit [] (!(x : xs)) = runsplit [x] xs
+        runsplit [] [] = []
+        runsplit [r] (!(x : xs)) | x > r = runsplit [r, x] xs
+        runsplit rl@(r : rs) ((!x) : xs)
+        runsplit run [] = [run]
+        split (!x) lo hi (y : ys)
+        to_heap (!k) (!x) (Branch y l r)
+        to_heap :: Ord a => Int -> a -> Tree a -> Tree a
+        to_heap k x Tip = Branch x Tip Tip
+        trins :: Ord a => [a] -> [a] -> [a] -> [a]
+        trins rev (x : xs) (y : ys)
+        trins rev [] (!(y : ys)) = trins [] ((reverse rev) ++ [y]) ys
+        trins rev xs [] = (reverse rev) ++ xs
+  where  
+  where  
+  where  
+  where  
+  where  
+  where (lo, hi) = partition ((>=) x) xs
+  where lo = [y | y <- xs, y <= x]
+  where split x lo hi [] = quickerSort lo ++ (x : quickerSort hi)
+data Tree a = Tip
+data Tree2 a = Tip2
 heapSort :: Ord a => [a] -> [a]
-heapSort xs = clear (heap (0::Int) xs)
+heapSort xs = clear (heap (0 :: Int) xs)
 import Data.List (partition)
-insertSort (x:xs)   = trins [] [x] xs
+insertSort (x : xs) = trins [] [x] xs
 insertSort :: Ord a => [a] -> [a]
-insertSort []	    = []
+insertSort [] = []
 mergeSort :: Ord a => [a] -> [a]
@@ -126,12 +115,12 @@
 module Sort where
-quickSort (x:xs) = (quickSort lo) ++ (x : quickSort hi)
+quickSort (x : xs) = (quickSort lo) ++ (x : quickSort hi)
 quickSort :: Ord a => [a] -> [a]
-quickSort []	 = []
-quickSort2 (x:xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
+quickSort [] = []
+quickSort2 (x : xs) = (quickSort2 lo) ++ (x : quickSort2 hi)
 quickSort2 :: Ord a => [a] -> [a]
-quickSort2 []	 = []
-quickerSort (x:xs)  = split x [] [] xs
+quickSort2 [] = []
+quickerSort (x : xs) = split x [] [] xs
 quickerSort :: Ord a => [a] -> [a]
-quickerSort []	    = []
-quickerSort [x]	    = [x]
+quickerSort [] = []
+quickerSort [x] = [x]
 treeSort :: Ord a => [a] -> [a]
make: *** [runtests] Error 1
