module Parse
       (Parser, faiL, okay, tok, sat, orelse, seQ, doo, sptok, just,
        listOf, many, sp, many1)
       where
 
infixr 6 `seQ`
 
infixl 5 `doo`
 
infixr 4 `orelse`
 
type Parser a = [Char] -> [(a, [Char])]
 
faiL :: Parser a
faiL inn = []
 
okay :: a -> Parser a
okay (!v) inn = [(v, inn)]
 
tok :: [Char] -> Parser [Char]
tok w (!inn) = [(w, drop n inn) | w == take n inn]
  where (!n) = length w
 
sat :: (Char -> Bool) -> Parser Char
sat p [] = []
sat (!p) (!((!(c : inn)))) = [(c, inn) | p c]
 
orelse :: Parser a -> Parser a -> Parser a
orelse p1 p2 inn = p1 inn ++ p2 inn
 
seQ :: Parser a -> Parser b -> Parser (a, b)
seQ p1 p2 (!inn)
  = [((v1, v2), inn2) | (v1, inn1) <- p1 inn,
     (!(v2, (!inn2))) <- p2 inn1]
 
doo :: Parser a -> (a -> b) -> Parser b
doo p f (!inn) = [(f v, inn1) | ((!v), (!inn1)) <- p inn]
 
just :: Parser a -> Parser a
just (!p) (!inn)
  = [(v, "") | (!(v, inn')) <- p inn, dropWhile (' ' ==) inn' == ""]
 
sp :: Parser a -> Parser a
sp (!p) = p . dropWhile (' ' ==)
 
sptok :: [Char] -> Parser [Char]
sptok = sp . tok
 
many :: Parser a -> Parser [a]
many (!p) = q
  where q = ((p `seQ` q) `doo` makeList) `orelse` (okay [])
 
many1 :: Parser a -> Parser [a]
many1 p = p `seQ` many p `doo` makeList
 
listOf :: Parser a -> Parser b -> Parser [a]
listOf (!p) (!s)
  = p `seQ` many (s `seQ` p) `doo` nonempty `orelse` okay []
  where nonempty ((!x), (!xs)) = x : (map snd xs)
 
makeList :: (a, [a]) -> [a]
makeList (!(x, xs)) = x : xs