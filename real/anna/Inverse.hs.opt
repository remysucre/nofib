module Inverse where
import BaseDefs
import Utils
import MyUtils
import AbstractVals2
import SuccsAndPreds2
import AbstractMisc
import Apply
 
inMinInverse :: Bool -> Domain -> Route -> Route -> [FrontierElem]
inMinInverse (!mindless) fDomain ((!(Rep (!f)))) res
  | mindless = second (inMMI_mindless fDomain f res)
  | otherwise = second (inMMI fDomain f res)
 
inMaxInverse :: Bool -> Domain -> Route -> Route -> [FrontierElem]
inMaxInverse (!mindless) (!fDomain) ((!(Rep f))) res
  | mindless = first (inMMI_mindless fDomain f res)
  | otherwise = first (inMMI fDomain f res)
 
inMMI_mindless ::
               Domain -> Rep -> Route -> ([FrontierElem], [FrontierElem])
inMMI_mindless (Func dss dt) f a
  = let totalInverseImage = inInverse_mindless dss f a in
      (avMaxfrel totalInverseImage, avMinfrel totalInverseImage)
 
inNormalise ::
            [FrontierElem] ->
              [FrontierElem] -> ([FrontierElem], [FrontierElem])
inNormalise (!max) (!min)
  = let (!new_max) = filter (`avAboveMin1frel` min) max
        (!new_min) = filter (`avBelowMax0frel` new_max) min
      in (new_max, new_min)
 
inIntersect ::
            ([FrontierElem], [FrontierElem]) ->
              ([FrontierElem], [FrontierElem]) ->
                ([FrontierElem], [FrontierElem])
inIntersect ((!max1), min1) (max2, (!min2))
  = let (!new_max)
          = avMaxfrel [x `avGLBfrel` y | x <- max1, (!y) <- max2]
        new_min = avMinfrel [x `avLUBfrel` y | x <- min1, (!y) <- min2]
      in inNormalise new_max new_min
 
inMMI :: Domain -> Rep -> Route -> ([FrontierElem], [FrontierElem])
inMMI (Func dss (!dt)) (!(RepTwo (Min1Max0 ar f1 f0))) (!Zero)
  = (f0, if null f0 then [] else [MkFrel (map avBottomR dss)])
inMMI (Func (!dss) Two) (RepTwo (!((!(Min1Max0 ar f1 f0))))) One
  = (if null f1 then [] else [MkFrel (map avTopR dss)], f1)
inMMI (!(Func (!dss) (!(Lift1 (!dts)))))
  (Rep1 (Min1Max0 ar (!lf_f1) (!lf_f0)) hfs) (!Stop1)
  = (lf_f0, if null lf_f0 then [] else [MkFrel (map avBottomR dss)])
inMMI (!(Func dss (!(Lift1 [dt]))))
  (!(Rep1 ((!(Min1Max0 ar (!lf_f1) lf_f0))) [hf])) (!((!(Up1 [r]))))
  = let (!(hf_maxI, hf_minI)) = inMMI (avUncurry dss dt) hf r
        min2 = avMinfrel [x `avLUBfrel` y | x <- hf_minI, y <- lf_f1]
      in inNormalise hf_maxI min2
inMMI ((!(Func dss ((!(Lift1 (!dts)))))))
  (!(Rep1 (!((!(Min1Max0 ar (!lf_f1) lf_f0)))) (!hfs)))
  (!(Up1 (!rs)))
  = let (!hf_domains) = map (avUncurry dss) dts
        (!hf_MMIs) = myZipWith3 inMMI hf_domains hfs rs
        (!(hf_maxI, hf_minI)) = foldr1 inIntersect hf_MMIs
        min2 = avMinfrel [x `avLUBfrel` y | (!x) <- hf_minI, (!y) <- lf_f1]
      in inNormalise hf_maxI min2
inMMI ((!(Func (!dss) ((!(Lift2 dts))))))
  (!((!(Rep2 (!lf) (!mf) hfs)))) a
  = let (!isoD) = Func dss (Lift1 [Lift1 dts])
        isoR = Rep1 lf [Rep1 mf hfs]
        isoA (!Stop2) = Stop1
        isoA Up2 = Up1 [Stop1]
        isoA (UpUp2 (!rs)) = Up1 [Up1 rs]
      in inMMI isoD isoR (isoA a)
inMMI (!dss) (!f) (!a) = inMMI_mindless dss f a
 
inInverse_mindless :: [Domain] -> Rep -> Route -> [FrontierElem]
inInverse_mindless (!argDomains) (!f) (!a)
  = let (!isPartialApp)
          = case a of
                (!(Rep (!_))) -> True
                (!_) -> False
        aRep
          = case a of
                (!(Rep r)) -> r
        (!actualArgDomains)
          = if isPartialApp then
              take (amRepArity f - amRepArity aRep) argDomains else argDomains
        (!allArgs) = myCartesianProduct (map amAllRoutes actualArgDomains)
      in [MkFrel args | (!args) <- allArgs, apApply (Rep f) args == a]